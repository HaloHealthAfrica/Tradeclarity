#!/usr/bin/env python3
"""
Production Swing Trading Scanner System
Version 4.0 | July 2025

Features:
- Real TwelveData API integration
- Fixed pattern detection logic
- Production error handling
- Database integration (SQLite/PostgreSQL)
- Rate limiting and connection pooling
- Comprehensive logging and monitoring
- Email/Slack notifications

Requirements:
- pip install requests pandas numpy sqlalchemy psycopg2-binary redis
"""

import os
import sys
import time
import json
import asyncio
import aiohttp
import logging
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from contextlib import asynccontextmanager

import pandas as pd
import numpy as np
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart

# Configure production logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    handlers=[
        logging.FileHandler("production_scanner.log", encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("ProductionScanner")

@dataclass
class TradingConfig:
    """Production trading configuration"""
    # API Configuration
    TWELVEDATA_API_KEY: str = os.getenv('TWELVEDATA_API_KEY', '')
    TWELVEDATA_BASE_URL: str = "https://api.twelvedata.com"
    TWELVEDATA_WS_URL: str = "wss://ws.twelvedata.com/v1/quotes/price"
    
    # Risk Management
    RISK_PER_TRADE: float = 0.02
    PORTFOLIO_HEAT_LIMIT: float = 0.06
    MAX_POSITIONS: int = 10
    
    # Pattern Parameters
    GAP_THRESHOLD: float = 0.005
    BREAKOUT_THRESHOLD: float = 0.001
    VOLUME_SPIKE_MULTIPLIER: float = 1.5
    MIN_VOLUME_THRESHOLD: int = 100000
    
    # Technical Indicators
    ATR_PERIOD: int = 14
    ATR_STOP_MULTIPLIER: float = 1.5
    EMA_SHORT: int = 20
    EMA_LONG: int = 50
    RSI_PERIOD: int = 14
    
    # Rate Limiting
    API_CALLS_PER_MINUTE: int = 60
    REQUEST_TIMEOUT: int = 30
    MAX_RETRIES: int = 3
    RETRY_DELAY: float = 1.0
    
    # Database
    DATABASE_URL: str = os.getenv('DATABASE_URL', 'sqlite:///trading_scanner.db')
    
    # Notifications
    SMTP_SERVER: str = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
    SMTP_PORT: int = int(os.getenv('SMTP_PORT', '587'))
    EMAIL_USER: str = os.getenv('EMAIL_USER', '')
    EMAIL_PASS: str = os.getenv('EMAIL_PASS', '')
    SLACK_WEBHOOK: str = os.getenv('SLACK_WEBHOOK', '')

@dataclass
class MarketData:
    """Market data structure"""
    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int

@dataclass
class TradingSignal:
    """Trading signal structure"""
    symbol: str
    pattern: str
    direction: str
    entry_price: float
    stop_loss: float
    target1: float
    target2: float
    confidence: float
    volume: int
    atr: float
    position_size: int
    risk_amount: float
    timestamp: datetime
    confluence_factors: List[str]

class DatabaseManager:
    """Production database manager"""
    
    def __init__(self, config: TradingConfig):
        self.config = config
        self.engine = create_engine(config.DATABASE_URL, echo=False)
        self.Session = sessionmaker(bind=self.engine)
        self._create_tables()
    
    def _create_tables(self):
        """Create necessary tables"""
        with self.engine.connect() as conn:
            # Market data table
            conn.execute(text("""
                CREATE TABLE IF NOT EXISTS market_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    open_price REAL NOT NULL,
                    high_price REAL NOT NULL,
                    low_price REAL NOT NULL,
                    close_price REAL NOT NULL,
                    volume INTEGER NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(symbol, timestamp)
                )
            """))
            
            # Trading signals table
            conn.execute(text("""
                CREATE TABLE IF NOT EXISTS trading_signals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    pattern TEXT NOT NULL,
                    direction TEXT NOT NULL,
                    entry_price REAL NOT NULL,
                    stop_loss REAL NOT NULL,
                    target1 REAL NOT NULL,
                    target2 REAL NOT NULL,
                    confidence REAL NOT NULL,
                    volume INTEGER NOT NULL,
                    atr REAL NOT NULL,
                    position_size INTEGER NOT NULL,
                    risk_amount REAL NOT NULL,
                    confluence_factors TEXT,
                    timestamp DATETIME NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """))
            
            # Scanner status table
            conn.execute(text("""
                CREATE TABLE IF NOT EXISTS scanner_status (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    status TEXT NOT NULL,
                    message TEXT,
                    symbols_monitored INTEGER,
                    signals_generated INTEGER,
                    last_update DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """))
            
            conn.commit()
            logger.info("Database tables created/verified")
    
    def save_market_data(self, data: MarketData):
        """Save market data to database"""
        try:
            with self.engine.connect() as conn:
                conn.execute(text("""
                    INSERT OR REPLACE INTO market_data 
                    (symbol, timestamp, open_price, high_price, low_price, close_price, volume)
                    VALUES (:symbol, :timestamp, :open_price, :high_price, :low_price, :close_price, :volume)
                """), {
                    'symbol': data.symbol,
                    'timestamp': data.timestamp,
                    'open_price': data.open,
                    'high_price': data.high,
                    'low_price': data.low,
                    'close_price': data.close,
                    'volume': data.volume
                })
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to save market data for {data.symbol}: {e}")
    
    def save_trading_signal(self, signal: TradingSignal):
        """Save trading signal to database"""
        try:
            with self.engine.connect() as conn:
                conn.execute(text("""
                    INSERT INTO trading_signals 
                    (symbol, pattern, direction, entry_price, stop_loss, target1, target2,
                     confidence, volume, atr, position_size, risk_amount, confluence_factors, timestamp)
                    VALUES (:symbol, :pattern, :direction, :entry_price, :stop_loss, :target1, :target2,
                            :confidence, :volume, :atr, :position_size, :risk_amount, :confluence_factors, :timestamp)
                """), {
                    'symbol': signal.symbol,
                    'pattern': signal.pattern,
                    'direction': signal.direction,
                    'entry_price': signal.entry_price,
                    'stop_loss': signal.stop_loss,
                    'target1': signal.target1,
                    'target2': signal.target2,
                    'confidence': signal.confidence,
                    'volume': signal.volume,
                    'atr': signal.atr,
                    'position_size': signal.position_size,
                    'risk_amount': signal.risk_amount,
                    'confluence_factors': json.dumps(signal.confluence_factors),
                    'timestamp': signal.timestamp
                })
                conn.commit()
                logger.info(f"Saved trading signal: {signal.symbol} {signal.pattern}")
        except Exception as e:
            logger.error(f"Failed to save trading signal: {e}")
    
    def get_recent_signals(self, hours: int = 24) -> List[Dict]:
        """Get recent trading signals"""
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text("""
                    SELECT * FROM trading_signals 
                    WHERE timestamp > datetime('now', '-{} hours')
                    ORDER BY timestamp DESC
                """.format(hours)))
                return [dict(row._mapping) for row in result]
        except Exception as e:
            logger.error(f"Failed to get recent signals: {e}")
            return []

class TwelveDataClient:
    """Production TwelveData API client with rate limiting and error handling"""
    
    def __init__(self, config: TradingConfig):
        self.config = config
        self.session = None
        self.rate_limiter = asyncio.Semaphore(config.API_CALLS_PER_MINUTE)
        self.last_request_time = 0
        
        if not config.TWELVEDATA_API_KEY:
            raise ValueError("TWELVEDATA_API_KEY environment variable is required")
    
    async def __aenter__(self):
        connector = aiohttp.TCPConnector(limit=10)
        timeout = aiohttp.ClientTimeout(total=self.config.REQUEST_TIMEOUT)
        self.session = aiohttp.ClientSession(connector=connector, timeout=timeout)
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def _make_request(self, endpoint: str, params: Dict) -> Dict:
        """Make rate-limited API request with retries"""
        async with self.rate_limiter:
            # Rate limiting - ensure minimum time between requests
            current_time = time.time()
            time_since_last = current_time - self.last_request_time
            if time_since_last < 1.0:  # Minimum 1 second between requests
                await asyncio.sleep(1.0 - time_since_last)
            
            params['apikey'] = self.config.TWELVEDATA_API_KEY
            url = f"{self.config.TWELVEDATA_BASE_URL}/{endpoint}"
            
            for attempt in range(self.config.MAX_RETRIES):
                try:
                    async with self.session.get(url, params=params) as response:
                        self.last_request_time = time.time()
                        
                        if response.status == 200:
                            data = await response.json()
                            if 'status' in data and data['status'] == 'error':
                                raise Exception(f"API Error: {data.get('message', 'Unknown error')}")
                            return data
                        elif response.status == 429:  # Rate limit exceeded
                            wait_time = (attempt + 1) * 2
                            logger.warning(f"Rate limit hit, waiting {wait_time}s")
                            await asyncio.sleep(wait_time)
                        else:
                            response.raise_for_status()
                            
                except asyncio.TimeoutError:
                    logger.warning(f"Request timeout (attempt {attempt + 1})")
                    if attempt < self.config.MAX_RETRIES - 1:
                        await asyncio.sleep(self.config.RETRY_DELAY * (attempt + 1))
                except Exception as e:
                    logger.error(f"Request failed (attempt {attempt + 1}): {e}")
                    if attempt < self.config.MAX_RETRIES - 1:
                        await asyncio.sleep(self.config.RETRY_DELAY * (attempt + 1))
                    else:
                        raise
            
            raise Exception(f"Failed to make request after {self.config.MAX_RETRIES} attempts")
    
    async def get_time_series(self, symbol: str, interval: str = '1day', outputsize: int = 50) -> pd.DataFrame:
        """Get historical time series data"""
        try:
            params = {
                'symbol': symbol,
                'interval': interval,
                'outputsize': outputsize,
                'format': 'JSON'
            }
            
            data = await self._make_request('time_series', params)
            
            if 'values' not in data:
                logger.error(f"No values in response for {symbol}")
                return pd.DataFrame()
            
            # Convert to DataFrame
            df = pd.DataFrame(data['values'])
            df['datetime'] = pd.to_datetime(df['datetime'])
            df.set_index('datetime', inplace=True)
            df.sort_index(inplace=True)
            
            # Convert to numeric
            numeric_columns = ['open', 'high', 'low', 'close', 'volume']
            for col in numeric_columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            
            logger.debug(f"Retrieved {len(df)} bars for {symbol}")
            return df
            
        except Exception as e:
            logger.error(f"Failed to get time series for {symbol}: {e}")
            return pd.DataFrame()
    
    async def get_real_time_price(self, symbol: str) -> Optional[Dict]:
        """Get real-time price data"""
        try:
            params = {
                'symbol': symbol,
                'format': 'JSON'
            }
            
            data = await self._make_request('price', params)
            return {
                'symbol': symbol,
                'price': float(data['price']),
                'timestamp': datetime.now()
            }
            
        except Exception as e:
            logger.error(f"Failed to get real-time price for {symbol}: {e}")
            return None

class TechnicalAnalyzer:
    """Production technical analysis engine"""
    
    def __init__(self, config: TradingConfig):
        self.config = config
    
    def calculate_atr(self, df: pd.DataFrame, period: int = None) -> float:
        """Calculate Average True Range"""
        if df.empty or len(df) < 2:
            return 0.0
            
        period = period or self.config.ATR_PERIOD
        
        try:
            df = df.copy()
            df['prev_close'] = df['close'].shift(1)
            df['tr1'] = df['high'] - df['low']
            df['tr2'] = abs(df['high'] - df['prev_close'])
            df['tr3'] = abs(df['low'] - df['prev_close'])
            df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)
            
            atr = df['tr'].rolling(window=period, min_periods=1).mean().iloc[-1]
            return float(atr) if not pd.isna(atr) else 0.0
            
        except Exception as e:
            logger.error(f"ATR calculation error: {e}")
            return 0.0
    
    def calculate_rsi(self, df: pd.DataFrame, period: int = None) -> float:
        """Calculate Relative Strength Index"""
        if df.empty or len(df) < 2:
            return 50.0
            
        period = period or self.config.RSI_PERIOD
        
        try:
            df = df.copy()
            delta = df['close'].diff()
            
            gain = delta.where(delta > 0, 0)
            loss = -delta.where(delta < 0, 0)
            
            avg_gain = gain.rolling(window=period, min_periods=1).mean()
            avg_loss = loss.rolling(window=period, min_periods=1).mean()
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            
            return float(rsi.iloc[-1]) if not pd.isna(rsi.iloc[-1]) else 50.0
            
        except Exception as e:
            logger.error(f"RSI calculation error: {e}")
            return 50.0
    
    def is_uptrend(self, df: pd.DataFrame) -> bool:
        """Determine if symbol is in uptrend"""
        if df.empty or len(df) < max(self.config.EMA_SHORT, self.config.EMA_LONG):
            return False
            
        try:
            df = df.copy()
            df['ema_short'] = df['close'].ewm(span=self.config.EMA_SHORT).mean()
            df['ema_long'] = df['close'].ewm(span=self.config.EMA_LONG).mean()
            
            return df['ema_short'].iloc[-1] > df['ema_long'].iloc[-1]
            
        except Exception as e:
            logger.error(f"Trend calculation error: {e}")
            return False
    
    def detect_patterns(self, df: pd.DataFrame, current_price: float) -> List[Dict]:
        """Detect trading patterns - FIXED LOGIC"""
        if df.empty or len(df) < 3:
            return []
        
        patterns = []
        
        try:
            # Get the last 3 bars
            current_bar = df.iloc[-1]
            prev_bar = df.iloc[-2]
            prev_prev_bar = df.iloc[-3]
            
            # 1. Inside Bar Pattern Detection
            is_inside_bar = (current_bar['high'] < prev_bar['high'] and 
                           current_bar['low'] > prev_bar['low'])
            
            if is_inside_bar:
                # Bullish breakout - FIXED: Changed elif to if
                breakout_level = current_bar['high'] * (1 + self.config.BREAKOUT_THRESHOLD)
                if current_price > breakout_level:
                    patterns.append({
                        'pattern': 'Inside Bar Bullish Breakout',
                        'direction': 'BUY',
                        'entry': current_price,
                        'stop': current_bar['low'],
                        'confidence_base': 110
                    })
                
                # Bearish breakdown - FIXED: This is now a separate if statement
                breakdown_level = current_bar['low'] * (1 - self.config.BREAKOUT_THRESHOLD)
                if current_price < breakdown_level:
                    patterns.append({
                        'pattern': 'Inside Bar Bearish Breakdown',
                        'direction': 'SELL',
                        'entry': current_price,
                        'stop': current_bar['high'],
                        'confidence_base': 110
                    })
            
            # 2. Outside Bar Pattern Detection
            is_outside_bar = (current_bar['high'] > prev_bar['high'] and 
                            current_bar['low'] < prev_bar['low'])
            
            if is_outside_bar:
                # Bullish outside bar
                if current_bar['close'] > current_bar['open']:
                    breakout_level = current_bar['high'] * (1 + self.config.BREAKOUT_THRESHOLD)
                    if current_price > breakout_level:
                        patterns.append({
                            'pattern': 'Outside Bar Bullish Follow-Through',
                            'direction': 'BUY',
                            'entry': current_price,
                            'stop': current_bar['low'],
                            'confidence_base': 115
                        })
                
                # Bearish outside bar
                if current_bar['close'] < current_bar['open']:
                    breakdown_level = current_bar['low'] * (1 - self.config.BREAKOUT_THRESHOLD)
                    if current_price < breakdown_level:
                        patterns.append({
                            'pattern': 'Outside Bar Bearish Follow-Through',
                            'direction': 'SELL',
                            'entry': current_price,
                            'stop': current_bar['high'],
                            'confidence_base': 115
                        })
            
            # 3. Gap Detection
            gap_up = current_bar['open'] > prev_bar['close'] * (1 + self.config.GAP_THRESHOLD)
            gap_down = current_bar['open'] < prev_bar['close'] * (1 - self.config.GAP_THRESHOLD)
            
            # Gap up breakout
            if gap_up and current_price > current_bar['high']:
                patterns.append({
                    'pattern': 'Gap Up Breakout',
                    'direction': 'BUY',
                    'entry': current_price,
                    'stop': current_bar['low'],
                    'confidence_base': 120
                })
            
            # Gap down breakdown
            if gap_down and current_price < current_bar['low']:
                patterns.append({
                    'pattern': 'Gap Down Breakdown',
                    'direction': 'SELL',
                    'entry': current_price,
                    'stop': current_bar['high'],
                    'confidence_base': 120
                })
            
            # 4. Volume validation for all patterns
            avg_volume = df['volume'].rolling(window=20, min_periods=5).mean().iloc[-1]
            current_volume = current_bar['volume']
            
            # Filter patterns with insufficient volume
            valid_patterns = []
            for pattern in patterns:
                if (current_volume >= self.config.MIN_VOLUME_THRESHOLD and 
                    current_volume >= avg_volume * self.config.VOLUME_SPIKE_MULTIPLIER):
                    valid_patterns.append(pattern)
                else:
                    logger.debug(f"Pattern {pattern['pattern']} filtered due to low volume")
            
            return valid_patterns
            
        except Exception as e:
            logger.error(f"Pattern detection error: {e}")
            return []

class NotificationManager:
    """Production notification system"""
    
    def __init__(self, config: TradingConfig):
        self.config = config
    
    async def send_signal_alert(self, signal: TradingSignal):
        """Send trading signal notification"""
        try:
            # Email notification
            if self.config.EMAIL_USER and self.config.EMAIL_PASS:
                await self._send_email(signal)
            
            # Slack notification
            if self.config.SLACK_WEBHOOK:
                await self._send_slack(signal)
                
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
    
    async def _send_email(self, signal: TradingSignal):
        """Send email alert"""
        try:
            msg = MimeMultipart()
            msg['From'] = self.config.EMAIL_USER
            msg['To'] = self.config.EMAIL_USER  # Send to self for now
            msg['Subject'] = f"Trading Signal: {signal.symbol} {signal.pattern}"
            
            body = f"""
            Trading Signal Generated
            
            Symbol: {signal.symbol}
            Pattern: {signal.pattern}
            Direction: {signal.direction}
            Entry Price: ${signal.entry_price:.2f}
            Stop Loss: ${signal.stop_loss:.2f}
            Target 1: ${signal.target1:.2f}
            Target 2: ${signal.target2:.2f}
            Confidence: {signal.confidence:.1f}%
            Position Size: {signal.position_size} shares
            Risk Amount: ${signal.risk_amount:.2f}
            
            Confluence Factors: {', '.join(signal.confluence_factors)}
            
            Generated at: {signal.timestamp}
            """
            
            msg.attach(MimeText(body, 'plain'))
            
            server = smtplib.SMTP(self.config.SMTP_SERVER, self.config.SMTP_PORT)
            server.starttls()
            server.login(self.config.EMAIL_USER, self.config.EMAIL_PASS)
            server.send_message(msg)
            server.quit()
            
            logger.info(f"Email alert sent for {signal.symbol}")
            
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
    
    async def _send_slack(self, signal: TradingSignal):
        """Send Slack notification"""
        try:
            payload = {
                "text": f"🚨 Trading Signal: {signal.symbol}",
                "attachments": [{
                    "color": "good" if signal.direction == "BUY" else "danger",
                    "fields": [
                        {"title": "Pattern", "value": signal.pattern, "short": True},
                        {"title": "Direction", "value": signal.direction, "short": True},
                        {"title": "Entry", "value": f"${signal.entry_price:.2f}", "short": True},
                        {"title": "Stop", "value": f"${signal.stop_loss:.2f}", "short": True},
                        {"title": "Confidence", "value": f"{signal.confidence:.1f}%", "short": True},
                        {"title": "Risk", "value": f"${signal.risk_amount:.2f}", "short": True}
                    ]
                }]
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(self.config.SLACK_WEBHOOK, json=payload) as response:
                    if response.status == 200:
                        logger.info(f"Slack alert sent for {signal.symbol}")
                    else:
                        logger.error(f"Slack webhook failed: {response.status}")
                        
        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")

class ProductionScanner:
    """Production-ready trading scanner"""
    
    def __init__(self, portfolio_value: float = 100000):
        self.config = TradingConfig()
        self.portfolio_value = portfolio_value
        self.db = DatabaseManager(self.config)
        self.analyzer = TechnicalAnalyzer(self.config)
        self.notifier = NotificationManager(self.config)
        
        # State management
        self.watchlist = []
        self.active_signals = []
        self.last_scan_time = {}
        self.running = False
        
        logger.info("Production Scanner initialized")
    
    def add_symbols(self, symbols: List[str]):
        """Add symbols to watchlist"""
        self.watchlist.extend(symbols)
        self.watchlist = list(set(self.watchlist))  # Remove duplicates
        logger.info(f"Watchlist updated: {len(self.watchlist)} symbols")
    
    def calculate_position_size(self, entry_price: float, stop_price: float) -> Tuple[int, float]:
        """Calculate position size based on risk management"""
        risk_per_share = abs(entry_price - stop_price)
        if risk_per_share == 0:
            return 0, 0
            
        risk_amount = self.portfolio_value * self.config.RISK_PER_TRADE
        position_size = int(risk_amount / risk_per_share)
        
        return position_size, risk_amount
    
    def calculate_confluence_score(self, symbol: str, df: pd.DataFrame, direction: str, base_confidence: float) -> Tuple[float, List[str]]:
        """Calculate confluence score with multiple factors"""
        score = base_confidence
        factors = []
        
        try:
            # Volume confluence
            avg_volume = df['volume'].rolling(window=20, min_periods=5).mean().iloc[-1]
            current_volume = df['volume'].iloc[-1]
            if current_volume >= avg_volume * self.config.VOLUME_SPIKE_MULTIPLIER:
                score *= 1.25
                factors.append("Volume Spike")
            
            # Trend alignment
            is_uptrend = self.analyzer.is_uptrend(df)
            if (direction == "BUY" and is_uptrend) or (direction == "SELL" and not is_uptrend):
                score *= 1.15
                factors.append("Trend Aligned")
            
            # RSI confluence
            rsi = self.analyzer.calculate_rsi(df)
            if direction == "BUY" and 40 < rsi < 70:
                score *= 1.10
                factors.append(f"RSI {rsi:.1f}")
            elif direction == "SELL" and 30 < rsi < 60:
                score *= 1.10
                factors.append(f"RSI {rsi:.1f}")
            
            # Cap at maximum
            score = min(score, 200.0)
            
        except Exception as e:
            logger.error(f"Confluence calculation error for {symbol}: {e}")
        
        return score, factors
    
    async def scan_symbol(self, symbol: str):
        """Scan individual symbol for patterns"""
        try:
            # Rate limiting per symbol
            last_scan = self.last_scan_time.get(symbol, 0)
            if time.time() - last_scan < 60:  # Minimum 1 minute between scans
                return
                
            async with TwelveDataClient(self.config) as client:
                # Get historical data
                df = await client.get_time_series(symbol, '1day', 100)
                if df.empty:
                    logger.warning(f"No data received for {symbol}")
                    return
                
                # Get current price
                current_data = await client.get_real_time_price(symbol)
                if not current_data:
                    logger.warning(f"No current price for {symbol}")
                    return
                    
                current_price = current_data['price']
                
                # Detect patterns
                patterns = self.analyzer.detect_patterns(df, current_price)
                
                for pattern_data in patterns:
                    await self._process_pattern(symbol, df, current_price, pattern_data)
                
                self.last_scan_time[symbol] = time.time()
                
        except Exception as e:
            logger.error(f"Error scanning {symbol}: {e}")
    
    async def _process_pattern(self, symbol: str, df: pd.DataFrame, current_price: float, pattern_data: Dict):
        """Process detected pattern and generate signal"""
        try:
            # Calculate position size
            entry_price = pattern_data['entry']