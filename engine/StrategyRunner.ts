import { Candle, TradeSignal, Strategy } from '../types';
import { streamRouter } from '../data/twelvedataClient/streamRouter';
import { createModuleLogger } from '../utils/logger';
import { handleSignal } from './TradeOrchestrator';
import { loadAllStrategies, discoverStrategies } from '../strategies/StrategyLoader';

const logger = createModuleLogger('StrategyRunner');

interface StrategyInstance {
  strategy: Strategy;
  symbols: string[];
  intervals: string[];
  isActive: boolean;
}

class StrategyRunner {
  private strategies: Map<string, StrategyInstance> = new Map();
  private isRunning = false;

  public async registerStrategy(strategy: Strategy): Promise<void> {
    try {
      logger.info(`Registering strategy: ${strategy.name}`, {
        symbols: strategy.symbols,
        intervals: strategy.intervals
      });

      // Initialize the strategy
      await strategy.initialize();

      const instance: StrategyInstance = {
        strategy,
        symbols: strategy.symbols,
        intervals: strategy.intervals,
        isActive: strategy.enabled
      };

      this.strategies.set(strategy.name, instance);

      // Subscribe to all symbol/interval combinations
      for (const symbol of strategy.symbols) {
        for (const interval of strategy.intervals) {
          streamRouter.subscribe(symbol, interval, (candle: Candle) => {
            this.handleCandle(strategy.name, candle);
          }, strategy.name);
        }
      }

      logger.info(`Strategy ${strategy.name} registered successfully`);
    } catch (error) {
      logger.error(`Failed to register strategy ${strategy.name}`, error as Error);
      throw error;
    }
  }

  private async handleCandle(strategyName: string, candle: Candle): Promise<void> {
    const instance = this.strategies.get(strategyName);
    if (!instance || !instance.isActive) {
      return;
    }

    try {
      logger.debug(`Processing candle for ${strategyName}`, {
        symbol: candle.symbol,
        interval: candle.interval,
        price: candle.close
      });

      const signal = await instance.strategy.onCandle(candle);
      
      if (signal) {
        logger.info(`Signal generated by ${strategyName}`, {
          symbol: signal.symbol,
          direction: signal.direction,
          confidence: signal.confidence
        });

        await handleSignal(signal);
      }
    } catch (error) {
      logger.error(`Error processing candle for ${strategyName}`, error as Error, {
        symbol: candle.symbol,
        interval: candle.interval
      });
    }
  }

  public async start(): Promise<void> {
    if (this.isRunning) {
      logger.warn('StrategyRunner is already running');
      return;
    }

    try {
      logger.info('Starting StrategyRunner');

      // Discover available strategies
      discoverStrategies();

      // Auto-load all configured strategies
      const strategies = await loadAllStrategies();
      
      // Register all loaded strategies
      for (const strategy of strategies) {
        await this.registerStrategy(strategy);
      }

      this.isRunning = true;
      logger.info(`StrategyRunner started with ${strategies.length} strategies`);
    } catch (error) {
      logger.error('Failed to start StrategyRunner', error as Error);
      throw error;
    }
  }

  public async stop(): Promise<void> {
    if (!this.isRunning) {
      logger.warn('StrategyRunner is not running');
      return;
    }

    this.isRunning = false;
    logger.info('Stopping StrategyRunner');

    // Cleanup all strategies
    for (const [name, instance] of this.strategies) {
      try {
        await instance.strategy.cleanup();
        logger.info(`Cleaned up strategy: ${name}`);
      } catch (error) {
        logger.error(`Error cleaning up strategy ${name}`, error as Error);
      }
    }

    // Clear all stream subscriptions
    streamRouter.clearAll();
  }

  public getActiveStrategies(): string[] {
    return Array.from(this.strategies.keys()).filter(name => {
      const instance = this.strategies.get(name);
      return instance?.isActive;
    });
  }

  public getStrategyStatus(strategyName: string): boolean {
    const instance = this.strategies.get(strategyName);
    return instance?.isActive || false;
  }

  public async enableStrategy(strategyName: string): Promise<void> {
    const instance = this.strategies.get(strategyName);
    if (instance) {
      instance.isActive = true;
      logger.info(`Enabled strategy: ${strategyName}`);
    } else {
      logger.warn(`Strategy not found: ${strategyName}`);
    }
  }

  public async disableStrategy(strategyName: string): Promise<void> {
    const instance = this.strategies.get(strategyName);
    if (instance) {
      instance.isActive = false;
      logger.info(`Disabled strategy: ${strategyName}`);
    } else {
      logger.warn(`Strategy not found: ${strategyName}`);
    }
  }
}

// Export singleton instance
export const strategyRunner = new StrategyRunner();

// Legacy function for backward compatibility
export const registerStrategy = (symbol: string, tf: string, run: Function) => {
  logger.warn('Using deprecated registerStrategy function. Use StrategyRunner class instead.');
  streamRouter.subscribe(symbol, tf, (newCandle: Candle) => {
    run(symbol, tf, newCandle);
  }, 'legacy');
};
